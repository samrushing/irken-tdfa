(include "lib/basis.scm")
(include "lib/random.scm")
(include "set.scm")

;; XXX test with more complicated keys (like records)
;; XXX test with a set of sets.

(define (t0)
  (let ((nums '(3 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3 2 3))
	(s0 (list->set nums < (set/empty)))
	(s1 (list->set (reverse nums) < (set/empty))))
    (printn (set->list s0))
    (printn (set->list s1))
    (printn (cmp-repr (set/cmp s0 s1 <)))
    ))

(define (t1)
  (let ((nums0 '(3 1 4 1 5 9))
	(nums1 '(2 7 1 8 2 8))
	(s0 (list->set nums0 < (set/empty)))
	(s1 (list->set nums1 < (set/empty))))
    (printn (set->list s0))
    (printn (set->list s1))
    (printn (cmp-repr (set/cmp s0 s1 <)))
    (printn (cmp-repr (set/cmp s1 s0 <)))
    ))

(define (t2)
  (let ((nums '(3 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3 2 3))
	(s0 (list->set nums < (set/empty))))
    (printf "set {")
    (for-set x s0 (printf (int x) " "))
    (printf "}\n")
    ))

(define int-set< (make-set-cmp <))

(define (t3)
  (let ((nums0 '(3 1 4 1 5 9))
	(nums1 '(2 7 1 8 2 8))
	(s0 (list->set nums0 < (set/empty)))
	(s1 (list->set nums1 < (set/empty)))
	(nums2 '(1 2 3))
	(nums3 '(9 8 7))
	(s2 (list->set nums2 < (set/empty)))
	(s3 (list->set nums3 < (set/empty)))
	(ss0 (list->set (LIST s0 s1 s2 s3) int-set< (set/empty))))
    (printf "set of sets {\n")
    (for-set x ss0
      (printf "  {")
      (for-set y x
	(printf (int y) " "))
      (printf "}\n")
      )
    (printf "}\n")
    ))

(define (t4)
  (srandom 314159265)
  (let ((s0 (set/empty))
	(r0 '())
	(r1 '())
	)
    (for-range i 100
      (set/add! s0 < (mod (random) 10000)))
    (printf "{")
    (for-set x s0
      (printf (int x) " ")
      (if (and (not (< x 4000)) (< x 6000)) (PUSH r0 x))
      )
    (printf "}\n")
    (printn (reverse r0))
    (tree/range s0 < 4000 6000 (lambda (k v) (PUSH r1 k)))
    (printn (reverse r1))
    (printn (set/range->list s0 < 4000 6000))
    )
  )

(define (t5)
  (let ((s0 (set/empty))
	(s1 (set/empty)))
    (for-range i 20
      (set/add! s0 < (mod (random) 10000))
      (set/add! s1 < (mod (random) 10000)))
    (for-set2 a b s0 s1
       (printf "a=" (int a) " b= " (int b) "\n")
       )
    ))

(define (t6)
  (let ((s0 (list->set '(1 2 3) < (set/empty)))
	(s1 (list->set '(4 5 6) < (set/empty))))
    (printf "{" (join int->string " " (set->list (set/union < s0 s1))) "}\n")
    ))

(define (t7)
  (let ((s0 (list->set '(1 2 3 4) < (set/empty)))
	(s1 (list->set '(2 3 4 5) < (set/empty))))
    (printf "{" (join int->string " " (set->list (set/intersection < s0 s1))) "}\n")
    ))

(define (t8)
  (let ((s0 (list->set '(1 2 3 4 5 6 7 8 9) < (set/empty)))
	(s1 (list->set '(2 4 6 8) < (set/empty))))
    (printf "{" (join int->string " " (set->list (set/difference < s0 s1))) "}\n")
    ))

(define (t9)
  (let ((s (set/make < 3 1 4 1 5 9 2)))
    (printf "{" (join int->string " " (set->list s)) "}\n")
    ))

(define (t10)
  (let ((s0 (set/make < 1 2 3 4 5))
	(s1 (set/replace s0 < 3 9 7 1100 -1)))
    (printf "{" (join int->string " " (set->list s1)) "}\n")
    ))

;; note: 3 is present in the replacement set.
(define (t11)
  (let ((s0 (set/make < 1 2 3 4 5))
	(s1 (set/replace s0 < 3 9 7 3 -1)))
    (printf "{" (join int->string " " (set->list s1)) "}\n")
    ))

(define (t12)
  (let ((s0 (set/make < 3)))
    (printf "{" (join int->string " " (set->list s0)) "}\n")
    ))

(t0)
(t1)
(t2)
(t3)
(t4)
(t5)
(t6)
(t7)
(t8)
(t9)
(t10)
(t11)
(t12)
